Token模型实战：如何精准地在 Uniswap V2 下识别“买入”与“撤池子”行为？

前言

最近在为一个 Token 项目设计机制时，为了配合其特殊的价值捕获与通缩模型，项目方提出了一个看似简单却极具挑战的“不可能三角”需求。

这个需求触及了 Uniswap/PancakeSwap V2 底层机制的一个经典盲区。今天，我把这个极具实战价值的**“行为识别技巧”**分享出来。如果你正在设计带有复杂交互机制或特定流转规则的代币，这个方案很有用。

01 背景：一个“既要又要”的矛盾需求

为了构建可持续的价值循环，该项目的机制设计需要实施严格的链上流转管理。部分机制如下：

限制非白名单交易：项目上线后，为了防范自动化交易套利和非正常市场波动，普通用户禁止在 DEX 上进行 Swap（兑换）。

保障退出权益：为了保障用户的资产自主权，必须允许用户随时移除流动性（Remove Liquidity）。

难点在于： 在智能合约的代码视角里，“兑换行为”和“撤池子行为”长得简直一模一样。

这就好比只给你看一张背影照片，让你区分双胞胎——如果没有特殊的识别技巧，误判是必然的。

02 难点：代码视角下的“双胞胎”

为什么说它们很难区分？我们看看niswap/PancakeSwap V2的对应处理。

在 Uniswap/PancakeSwap V2 的标准中，无论是**“兑换（Swap）”还是“移除流动性（Burn）”**，对于 Token 合约来说，表现出的链上行为特征是完全一致的：

买入 (Swap)：Pair 合约把 Token 转给用户。

撤池子 (Remove Liquidity)：Pair 合约把 Token 转给用户。

在 _transfer(address from, address to, uint256 amount) 函数中，这两种操作的参数特征完全重合：

from == Pair 地址

to == 用户地址

很多经验不足的开发者容易在这里栽跟头，简单粗暴地写下：

// ❌ 错误示范：这会把撤池子也一起禁掉，导致合约功能异常
if (from == pairAddress) {
    revert("禁止买入"); 
}


一旦这样写，用户存进去的流动性就永远取不出来了，这将导致严重的合约逻辑漏洞和信任危机。

03 尝试：寻找破局的“试金石”

为了解决这个问题，我复盘了市面上现有的几种方案，但都不尽如人意：

方案 A（基于地址排序）：利用 Uniswap burn 函数内部转账顺序的固定性。

问题：逻辑晦涩，且对代币地址有硬性要求（必须大于或小于配对币地址），一旦更换配对资产（如从 USDT 换成 BNB），逻辑立即失效。

方案 B（基于 Gas 估算）：试图通过 Gas 使用量来区分。

问题：极不稳定，容易被复杂的路由路径干扰。

我们需要一个更底层、更本质、且无法伪造的判断依据。我决定回归 DeFi 的第一性原理：原子性与状态更新时序。

04 思考：回归买入与撤池子的常识

经过对 Uniswap V2 对应处理流程的仔细分析，我发现两者的代币流转存在一个本质的区别，很像“水位线”。

场景一：买入行为 (Buy)
当用户买入本币时，实际上是用“支付代币”（配对 Token，如 USDT）去池子里兑换“目标代币”（本币）。

代币流向： 外界的 USDT 快速流进 Pool。

状态瞬间： 在本币发生转账的那一刻（_transfer 触发时），Pool 里的 USDT 余额 (Balance) 必然是显著增加的，甚至超过了它账本上记录的 储备量 (Reserve)。 (水位超过了堤坝)

场景二：撤池行为 (Remove)
当用户撤池子时，是把 LP 凭证销毁，从池子里拿走 USDT 和 本币。

代币流向： Pool 里的 USDT 和 本币 都在流出。

状态瞬间： 无论如何，Pool 里的 USDT 余额 都不可能出现“显著增加”的情况，它是在减少的。
(水位在下降)

💡 发现区分办法： 我们可以通过对比 “配对 Token 在 Pool 中的实时余额” 与 “账本储备量” 的关系，来精准识别买入行为！

是买入： 配对 Token 余额 > 配对 Token 储备量

是撤池： 配对 Token 余额 <= 配对 Token 储备量

05 代码实现：直接可用版

原理通了，代码实现其实就相对简单很多了。我们只需要在合约里集成一个 view 类型的辅助函数。

以下代码基于 Solidity 0.8.x，适配 PancakeSwap/Uniswap V2，可直接用于生产环境：

/**
 * @dev 核心判断逻辑：判断当前交易是否为“买入”
 * 原理：利用 V2 Pair 合约“先转入代币，后更新储备”的乐观转账特性。
 * @return true = 是买入, false = 不是买入 (可能是撤池或普通转账)
 */
function _isBuyTransaction() internal view returns (bool) {
    // 1. 获取 Pair 合约实例
    IPancakePair pair = IPancakePair(pairAddress);

    // 2. 获取账本上的储备量 (Reserves)
    // 注意：这里的 Reserve 是上一次交易结束后的状态，尚未包含本次交易的变动
    (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();

    // 3. 获取配对币 (如 USDT/BNB) 在 Pair 中的真实余额
    // 这一步读取的是当前的“水位”，如果有人刚充钱进来买币，水位会瞬间升高
    uint256 pairTokenBalance = IERC20(USDT_ADDRESS).balanceOf(pairAddress);

    // 4. 确定配对币是 token0 还是 token1
    uint256 pairTokenReserve;
    if (token0 == USDT_ADDRESS) {
        pairTokenReserve = reserve0;
    } else {
        pairTokenReserve = reserve1;
    }

    // 5. 核心判据：水位线
    // 如果 真实余额 > 账本储备，说明有人刚充了 USDT 进来准备买币
    return pairTokenBalance > pairTokenReserve;
}

// 在 _transfer 中的实战应用
function _transfer(address from, address to, uint256 amount) internal override {
    // ... 其他逻辑 ...

    // 检测：如果资金从 Pair 流出 (from == pair)
    if (from == pairAddress) {
        // 且不是白名单用户
        if (!isWhitelist[to]) {
            // 调用判断函数
            if (_isBuyTransaction()) {
                // 拦截买入行为
                revert("Prohibit buying"); 
            } else {
                // 逻辑走到这里，说明是撤池子行为
                // 可以在这里放行，或者执行其他撤池相关的通缩逻辑（如销毁）
            }
        }
    }
    
    super._transfer(from, to, amount);
}


总结

这个方法的好用之处在于它利用了 Uniswap/PancakeSwap V2 底层的时序。它不需要复杂的数学计算，Gas 费消耗极低，且完全不需要担心代币地址排序的问题，是一个非常稳健的通用解决方案。

这意味着可以设计更复杂、更具博弈性的机制模型，而不必受限于基础合约逻辑的“误伤”。

如果你也在构思特殊的 Token 经济模型，希望这个思路能给你带来一些启发。
