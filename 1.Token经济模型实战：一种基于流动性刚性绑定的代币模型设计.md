
> **å‰è¨€**
> ç›®å‰çš„ Token é¡¹ç›®ç»æµæ¨¡å‹å±‚å‡ºä¸ç©·ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œä¸€ä¸ªé¡¹ç›®çš„åº•æ± ï¼ˆLiquidity Poolï¼‰æ˜¯ç”±é¡¹ç›®æ–¹åˆå§‹æ·»åŠ ï¼Œå†è¾…ä»¥ä¸€äº›æµåŠ¨æ€§æŒ–çŸ¿æœºåˆ¶ã€‚**ä½†ä¸ºäº†é¡¹ç›®çš„é•¿è¿œå‘å±•ï¼Œæˆ‘ä»¬å¯ä»¥è½¬æ¢æ€è·¯ï¼šå°†â€œå‚ä¸é¡¹ç›®â€çš„å”¯ä¸€å…¥å£ï¼Œè®¾è®¡ä¸ºâ€œæ·»åŠ åº•æ± â€ã€‚**

ä»Šå¤©ï¼Œåˆ†äº«ä¸€ä¸ª**å°†ç”¨æˆ·å¢é•¿ä¸åº•æ± åšåº¦è¿›è¡Œå¼ºç»‘å®š**çš„æœºåˆ¶è®¾è®¡æ€è·¯ã€‚

---

## 01 æ ¸å¿ƒå®ç°é€»è¾‘

è¿™ä¸ªæœºåˆ¶çš„æ ¸å¿ƒåœ¨äºï¼š**ç”¨æˆ·ä¸ç›´æ¥è´­ä¹°ä»£å¸ï¼Œè€Œæ˜¯é€šè¿‡æä¾›æµåŠ¨æ€§æ¥è·å–æƒç›Šã€‚** å…·ä½“äº¤äº’æµç¨‹å¦‚ä¸‹ï¼š

### 1. å…¥åœºå³åšå¸‚ (LP Entry)
ç”¨æˆ·å‚ä¸é¡¹ç›®çš„å”¯ä¸€æ–¹å¼æ˜¯é€šè¿‡æ·»åŠ åº•æ± ã€‚
- **å®ç°æ–¹å¼ï¼š** å‰ç«¯æˆ–åˆçº¦è‡ªåŠ¨ä¸ºç”¨æˆ·æ‰§è¡Œâ€œç»„ LPâ€æ“ä½œï¼ˆä¾‹å¦‚ï¼šç”¨æˆ·æŠ•å…¥ USDTï¼Œåˆçº¦è‡ªåŠ¨é…å¯¹å¹¶æ·»åŠ æµåŠ¨æ€§ï¼‰ã€‚

### 2. å‡­è¯ç½®æ¢ (Voucher Minting)
ç”¨æˆ·è·å¾—çš„ LP Tokenï¼ˆæµåŠ¨æ€§å‡­è¯ï¼‰å°†è¢«ç›´æ¥é”€æ¯ï¼Œä½œä¸ºäº¤æ¢ï¼Œåˆçº¦ä¼šåŒæ­¥ä¸ºç”¨æˆ·é“¸é€ å¯¹åº”çš„**â€œè´¨æŠ¼å‡­è¯ä»£å¸â€**ã€‚
- *è®¾è®¡æ„å›¾ï¼šé”æ­»æµåŠ¨æ€§ï¼Œé¿å…ä¼ ç»ŸæŒ–çŸ¿ä¸­çš„â€œæŒ–æå–â€å¯¼è‡´åº•æ± ç¬é—´è¢«æ’¤ç©ºã€‚*

### 3. çº¿æ€§é‡Šæ”¾ (Vesting Release)
ç³»ç»Ÿæ ¹æ®é¢„è®¾çš„é‡Šæ”¾è§„åˆ™ï¼Œæ¯å¤©ä¸ºç”¨æˆ·è§£é”/é‡Šæ”¾ä¸€å®šæ•°é‡çš„â€œè´¨æŠ¼å‡­è¯ä»£å¸â€ã€‚

### 4. é€€å‡ºä¸è·åˆ© (Exit & Reward)
ç”¨æˆ·å‡­å€Ÿå·²é‡Šæ”¾çš„â€œè´¨æŠ¼å‡­è¯ä»£å¸â€æ¥æå–å¥–åŠ±ã€‚
- **äº¤äº’é€»è¾‘ï¼š** åˆçº¦é”€æ¯ç”¨æˆ·çš„â€œè´¨æŠ¼å‡­è¯ä»£å¸â€ï¼Œå¹¶æ ¹æ®å½“å‰å‡€å€¼ï¼Œä»åº•æ± ä¸­å…‘æ¢å‡ºå¯¹åº”çš„ USDTã€‚

---

## 02 åŒä»£å¸æ¶æ„è®¾è®¡

åœ¨åˆçº¦å±‚é¢ï¼Œæˆ‘ä»¬éœ€è¦éƒ¨ç½²ä¸¤ä¸ª ERC20 ä»£å¸ï¼Œå„å¸å…¶èŒï¼š

**ğŸª™ æœ¬å¸ (Base Token)**
- **å®šä½ï¼š** ä»…ä½œä¸ºåº•æ± ä¸­çš„è®¡ä»·èµ„äº§å­˜åœ¨ã€‚
- **ç‰¹æ€§ï¼š** ä¸ç”¨äºå®é™…çš„å¸‚åœºæµé€šï¼Œä¸»è¦é”šå®šé¡¹ç›®ä»·å€¼ã€‚

**ğŸ“œ è´¨æŠ¼å‡­è¯ä»£å¸ (Voucher Token)**
- **å®šä½ï¼š** å®ƒæ˜¯ç”¨æˆ· LP Token çš„å½±å­å‡­è¯ï¼ŒåŒæ—¶ä¹Ÿæ˜¯åšå¸‚/è´¨æŠ¼å¥–åŠ±çš„è½½ä½“ã€‚
- **ç‰¹æ€§ï¼š** ç”¨æˆ·æŒæœ‰å®ƒï¼Œå³ä»£è¡¨æŒæœ‰åº•æ± çš„èµå›æƒã€‚

---

## 03 æœºåˆ¶ä»·å€¼æ€»ç»“

è¿™å¥—æ¨¡å‹æœ€å¤§çš„äº®ç‚¹åœ¨äº**åè„†å¼±æ€§**ï¼š

1. **å¼ºå…³è”ï¼š** å½»åº•ç»‘å®šäº†åº•æ± æ·±åº¦ä¸ç”¨æˆ·ä½“é‡ã€‚æ¯ä¸€ä¸ªæ–°ç”¨æˆ·çš„è¿›å…¥ï¼Œéƒ½å¿…ç„¶å¸¦æ¥åº•æ± åšåº¦çš„å¢åŠ ã€‚
2. **ç¨³å®šæ€§ï¼š** éšç€å¸‚åœºçš„è¿è¡Œå’Œç”¨æˆ·çš„å¢é•¿ï¼ŒæµåŠ¨æ€§çš„æ·±åº¦ä¼šä¸æ–­ç´¯ç§¯ï¼Œé¿å…äº†å•è¾¹ç ¸ç›˜å¯¼è‡´é¡¹ç›®å½’é›¶çš„é£é™©ã€‚

---

## 04 åˆçº¦ Demo ä»£ç ï¼ˆç®€åŒ–å®ç°ç‰ˆï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// æ¨¡æ‹Ÿ Uniswap V2 è·¯ç”±æ¥å£ï¼ˆç®€åŒ–ç‰ˆï¼‰
interface IUniswapV2Router {
    function addLiquidity(
        address tokenA, address tokenB,
        uint amountADesired, uint amountBDesired,
        uint amountAMin, uint amountBMin,
        address to, uint deadline
    ) external returns (uint amountA, uint amountB, uint liquidity);

    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint amountIn, uint amountOutMin,
        address[] calldata path, address to, uint deadline
    ) external;
}

/**
 * @title BaseToken (æœ¬å¸)
 * @dev ä»…ç”¨äºåº•æ± è®¡ä»·ï¼Œä¸åœ¨å¸‚åœºæµé€šã€‚æƒé™ä»…æˆä¿¡ç»™ä¸»åˆçº¦ã€‚
 */
contract BaseToken is ERC20, Ownable {
    constructor() ERC20("Base Project Token", "BASE") Ownable(msg.sender) {}

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }
}

/**
 * @title VoucherToken (è´¨æŠ¼å‡­è¯ä»£å¸)
 * @dev ç”¨æˆ·çš„æƒç›Šå‡­è¯ï¼Œé”šå®šåº•æ± è´¡çŒ®åº¦ã€‚
 */
contract VoucherToken is ERC20, Ownable {
    constructor() ERC20("Liquidity Voucher", "VOUCHER") Ownable(msg.sender) {}

    function mint(address to, uint256 amount) external onlyOwner {
        _mint(to, amount);
    }

    function burn(address from, uint256 amount) external onlyOwner {
        _burn(from, amount);
    }
}

/**
 * @title LiquidityGrowthSystem (æ ¸å¿ƒé€»è¾‘)
 * @notice å®ç°â€œç”¨æˆ·å¢é•¿ä¸åº•æ± åšåº¦å¼ºç»‘å®šâ€çš„æœºåˆ¶
 */
contract LiquidityGrowthSystem is Ownable {
    using SafeERC20 for IERC20;

    BaseToken public baseToken;
    VoucherToken public voucherToken;
    IERC20 public usdt;
    IUniswapV2Router public router;

    // è®°å½•ç”¨æˆ·å¯é¢†å–çš„ä»½é¢ï¼ˆç®€åŒ–ç‰ˆé‡Šæ”¾é€»è¾‘ï¼‰
    mapping(address => uint256) public userVestingBalance;

    constructor(
        address _usdt, 
        address _router,
        address _baseToken,
        address _voucherToken
    ) Ownable(msg.sender) {
        usdt = IERC20(_usdt);
        router = IUniswapV2Router(_router);
        baseToken = BaseToken(_baseToken);
        voucherToken = VoucherToken(_voucherToken);
    }

    // ==========================================
    // æ ¸å¿ƒé€»è¾‘ 1 & 2: å…¥åœºå³åšå¸‚ + å‡­è¯ç½®æ¢
    // ==========================================
    function joinProject(uint256 usdtAmount) external {
        // 1. è½¬ç§»ç”¨æˆ·çš„ USDT åˆ°åˆçº¦
        usdt.safeTransferFrom(msg.sender, address(this), usdtAmount);

        // 2. æ ¸å¿ƒï¼šé“¸é€ ç­‰å€¼çš„æœ¬å¸ (BaseToken) ç”¨äºé…å¯¹
        // æ³¨æ„ï¼šå®é™…ç”Ÿäº§ä¸­è¿™é‡Œéœ€è¦æ ¹æ®å½“å‰æ± å­ä»·æ ¼åŠ¨æ€è®¡ç®—
        baseToken.mint(address(this), usdtAmount);

        // 3. æˆæƒè·¯ç”±è¿›è¡Œç»„ LP
        usdt.approve(address(router), usdtAmount);
        baseToken.approve(address(router), usdtAmount);

        // 4. æ·»åŠ æµåŠ¨æ€§
        // æ³¨æ„ï¼šæ¥æ”¶è€…(to) è®¾ç½®ä¸º address(0) æˆ– 0xdeadï¼Œå³â€œé”€æ¯LPâ€
        // è¿™ä¸€æ­¥å®ç°äº†ã€åº•æ± æ·±åº¦æ°¸ä¹…é”å®šã€‘
        (,, uint256 liquidity) = router.addLiquidity(
            address(usdt),
            address(baseToken),
            usdtAmount,
            usdtAmount,
            0, 0,
            address(0xdead), // ç›´æ¥é”€æ¯ LP å‡­è¯
            block.timestamp
        );

        // 5. ä¸ºç”¨æˆ·é“¸é€ â€œè´¨æŠ¼å‡­è¯ä»£å¸â€ (Voucher)
        // è¿™ä¸€æ­¥å®ç°äº†ã€ç”¨æˆ·æƒç›Šä¸åº•æ± è´¡çŒ®çš„å¼ºç»‘å®šã€‘
        voucherToken.mint(msg.sender, liquidity);
        
        // ç®€å•è®°å½•æƒç›Šï¼ˆé…åˆåç»­é‡Šæ”¾é€»è¾‘ï¼‰
        userVestingBalance[msg.sender] += liquidity;
    }

    // ==========================================
    // æ ¸å¿ƒé€»è¾‘ 4: é€€å‡ºä¸è·åˆ©
    // ==========================================
    function exitReward(uint256 voucherAmount) external {
        require(userVestingBalance[msg.sender] >= voucherAmount, "Insufficient vested balance");

        // 1. é”€æ¯ç”¨æˆ·çš„å‡­è¯ä»£å¸
        // ç”¨æˆ·äº¤å›æƒç›Šï¼Œç³»ç»Ÿå‡†å¤‡å…‘ä»˜
        voucherToken.burn(msg.sender, voucherAmount);
        userVestingBalance[msg.sender] -= voucherAmount;

        // 2. å…‘ä»˜é€»è¾‘ï¼šç”±äº LP å·²é”€æ¯ï¼Œæ— æ³•æ’¤èµ„
        // æœºåˆ¶è½¬ä¸ºï¼šé“¸é€ æœ¬å¸ -> å–å‡ºæœ¬å¸æ¢å– USDT -> æ”¯ä»˜ç»™ç”¨æˆ·
        // è¿™ç§æ–¹å¼ä¿è¯äº†ç”¨æˆ·æ€»æ˜¯å¯ä»¥é€€å‡ºï¼Œä½†ä»·æ ¼å—å½“æ—¶åº•æ± æ·±åº¦å½±å“
        
        uint256 amountBaseToSwap = voucherAmount; // ç®€åŒ–æ±‡ç‡è®¡ç®—ï¼Œå®é™…éœ€æŒ‰å½“å‰å‡€å€¼
        baseToken.mint(address(this), amountBaseToSwap);
        baseToken.approve(address(router), amountBaseToSwap);

        address[] memory path = new address[](2);
        path[0] = address(baseToken);
        path[1] = address(usdt);

        // 3. è¿™é‡Œçš„ Swap å®é™…ä¸Šæ˜¯ç”±åº•æ± æä¾›æ·±åº¦æ¥æ”¯ä»˜ç”¨æˆ·ç¦»åœº
        // å®ç°äº†â€œåè„†å¼±â€ï¼šç”¨æˆ·è¶Šå¤šï¼Œæ± å­è¶Šåšï¼Œæ‰¿è½½åŠ›è¶Šå¼º
        router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amountBaseToSwap,
            0,
            path,
            msg.sender, // USDT ç›´æ¥æ‰“ç»™ç”¨æˆ·
            block.timestamp
        );
    }
}
